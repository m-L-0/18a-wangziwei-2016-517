1.name属性是Tensor、Operation的唯一标识符，使用name能实现跨语言环境的兼容，也有助于在TensorBoard中可视化
2.只能给Operation进行主动命名，Tensor的name由Operation根据自己的name与输出数量进行命名（所有的Tensor均由Operation产生）
3.Op的，命名规范是：数字、字母、下划线组成，不能以下划线开头，且不区分大小写
4.tf.no_op函数返回的是Op对象
5.在op的name加一个后缀避免name重复，不同的操作之间有相同的name也是如此
6.多个图中有相同的操作或name时，并不会互相影响
7.tf.Graph.get_tensor_by_name根据name获取Tensor
  tf.Graph.get_operation_by_name根据name获取Op
会话中，fetch一个Tensor，会返回一个Tensor，fetch一个Op，返回None。

8.name_scope可以为其作用域中的节点的name添加一个或多个前缀，并使用这些前缀作为划分内部和外部op范围的标记。同时在TensorBoard可视化时可以作为一个整体出现（也可以展开），并且name_scope可以嵌套使用，代表不同层级的功能的划分。

9.在一个name_scope的作用域中，可以填写name相同的Op，TensorFlow会自动加后缀。指定任意多个name_scope填写相同name的两个或多个name_scope，TensorFlow会自动给name_scope的name加上后缀。

10.name_scope可以嵌套，不同级的name_scope可以填入相同的name。

11.tf.get_variable()创建的变量不能使用name_scope加前缀，从外部传入的Tensor不能在name_scope中加上前缀。

12.variable_scope主要用于管理变量作用域以及与变量相关的操作，也可以给不同操作区域划分范围（添加name前缀），可以与tf.get_variable()等配合使用完成对变量的重复使用。

13.默认的variable_scope的name等于其对应的name_scope的name。

14.创建相同name的多个variable_scope时，相当于创建了一个variable_scope与多个name_scope

15.tf.get_variable()创建变量时不需要提供初始化的值，在同一作用域下，name相同抛出异常

16.variable_scope对象包含一个reuse属性，默认的值为None,是不可重用的，此时，tf.get_variable()是创建变量,值为True时，是可重用的，此时tf.get_variable()的用法变成利用name获取已存在的变量

17.variable_scope如果在嵌套的一个变量作用域里使用之前预定义的一个作用域，则会跳过当前变量作用域，保持预先存在的作用域不变